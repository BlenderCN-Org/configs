<div  lang="en"><div id="RIL_IMG_1" class="RIL_IMG"></div><br nodeIndex="205"><blockquote nodeIndex="58">
<p nodeIndex="59"><strong nodeIndex="206">This tutorial was written by <a href="http://www.cgstrive.com/" target="_blank" nodeIndex="207">the amazing Juri &Uuml;nt</a> and appeared in <a href="https://www.greatdigitalmags.com/view/3dartist/4389/3d-artist-issue-92" target="_blank" nodeIndex="208">issue 92 of 3D Artist</a></strong></p>
<h3 nodeIndex="60">Tools used</h3>
<p nodeIndex="61">Blender<br nodeIndex="209">
Houdini Indie</p>
</blockquote>
<p nodeIndex="62">We are going to explore alternative hard-surface modelling techniques in a semi-procedural, non-destructive setting &ndash; to do this we will break down the AstroMonkey render.</p>
<p nodeIndex="63">This tutorial will build on already dominant workflows such as sculpting, subdivision modelling, kitbashing and Boolean operations with an aim to bypass linear execution and many of the other limitations that they can sometimes impose.</p>
<p nodeIndex="64">By the end of this article you should have an overview of how to efficiently work within Blender&rsquo;s powerful ecosystem as well as how to utilise both Blender and Houdini in a way that is complementary to your existing workflows and applications.</p>
<p nodeIndex="65"><strong nodeIndex="210">Click on the images to enjoy them full size!</strong></p>
<h3 nodeIndex="66">Step 01 &ndash; Set up the workspace</h3>

<div id="RIL_IMG_2" class="RIL_IMG"></div>
This topic is often underestimated but is the core foundation of any strong artwork. It is also vitally important to display it efficiently so you get all the information, but are not helplessly cluttered to a point that you might ignore it all together. There are very good reference viewers like Kuadro available for free. We use a self-developed mindmapper that was designed for teamwork (with nodes, texts and planning) &ndash; it features sub-categorised image and video-based reference viewing on an infinite virtual canvas. For the primary reference, though, we will use Blender itself as it has very customisable and efficient UIs. Setting up several image panels is recommended, but it is also important to feel in control of your workspace and avoid having unused panels cluttering the screen! The most important thing to remember is that you can easily switch between all panels using Shift with the F1 to F12 hotkeys to show only the relevant panels as and when they are needed.<br nodeIndex="214"><h3 nodeIndex="68">Step 02 &ndash; Define the base</h3>

<div id="RIL_IMG_3" class="RIL_IMG"></div>
You can start with sculpting or a 2D concept. Sculpting has the benefit of a quick exploration of conceptual shapes in 3D space. You can use any application that you feel comfortable with, however the benefit of sculpting in a full DCC application such as Blender is that you have the ability to apply any tools of the software to accelerate the process. This includes use of traditional modelling tools, adding primitives and curves, modifiers (Lattices, Booleans, Arrays and so on), multi-axis symmetry and a lot more. You have the option to spend as much time on the design as you wish, depending on whether you will retopologise it closely or choose to explore it artistically by using traditional subdivision modelling. We worked quickly and minimally, as none of this data gets preserved.<br nodeIndex="218"><h3 nodeIndex="70">Step 03 &ndash; Model subdivisions and crease</h3>

<div id="RIL_IMG_4" class="RIL_IMG"></div>
Blender enables us to keep topology light and manageable, while dynamically creating most of the surface features through use of modifiers and other non-destructive techniques. We will work with subdivided surfaces as we are are interested in smooth, curved forms that are significantly harder to achieve than commonly used flat, planar surfaces. By adding a subdivision modifier to stack we have the option to use Edge Creasing to define hard corners without making any changes to our topology. This is very similar to other OpenSubD-supported applications, however Blender also has a very unique alternative called Edge Bevel. Setting bevel weight is nearly identical to working with creases but it dynamically bevels the actual mesh around the specified edges. The result is very clean and comes with a lot of control exposed by the modifier. The main benefit of using it over creasing is that it does not require heavy subdividing to see the effect, and it also exports very well in a variety of formats where creasing information would get lost. It is advisable to explore both techniques as you will apply them together.<br nodeIndex="222"><h3 nodeIndex="72">Step 04 &ndash; Work with multi-axis symmetry</h3>

<div id="RIL_IMG_5" class="RIL_IMG"></div>
The Mirror modifier (the 3ds Max equivalent is Symmetry) is an essential modifier. Using symmetry is a relatively simple topic, but it&rsquo;s good to understand how to make the most out of it. More specifically, very often we are dealing with both local as well as global symmetries. For example, the shoulder group hosts over 40 objects, each mirrored around a common custom object with a custom rotation. The result of that is also mirrored globally in an x direction. This can be achieved with two Mirror modifiers, each referencing a custom object that defines the mirroring position as well as the axis. We could work with instances (scale.x=-1), but this causes a massive overhead of managing and a lot of other errors (problems with normals, scene clutter, no welding and so on). Instead the Mirror modifier provides us with an efficient way to control our scene as we can disable the modifier at any time. More importantly it also welds the middle points of all objects based on individual thresholds, and enables us to break the uniformity by varying its order in the modifier stack! With many objects in the scene (over 400 in our case), the Mirror modifier can literally do half of the work for you.<br nodeIndex="226"><h3 nodeIndex="74">Step 05 &ndash; Use Solidify and Angle Limited Bevel</h3>

<div id="RIL_IMG_6" class="RIL_IMG"></div>
We can give our flat panels some thickness by adding the Solidify modifier (the 3ds Max equivalent is Shell). Since we are working with subdivision surfaces, the newly dynamically extruded form would become rounded if used prior to the Subdivision modifier. We can fix that by changing the Creasing parameters of the Solidify modifier in the Properties panel. An even better alternative is adding a Bevel modifier after Solidify, with Angle Limit mode. This will automatically detect the hard edges (corners) and dynamically bevel them. As a result we get very nice rounded corners that work perfectly with the Subdivision modifier.<br nodeIndex="230"><h3 nodeIndex="76">Step 06 &ndash; Split edges</h3>

<div id="RIL_IMG_7" class="RIL_IMG"></div>
We are now beginning to see the true benefits of modifiers, while our topology remains light and fast to edit. We can exploit this minimalism even further by adding an Edge Split modifier as the very first modifier in the stack. By selecting edges and applying a Make Sharp operator, the Edge Split modifier unwelds (splits) these edges from one another. In combination with Solidify and Subdivision (subsurf) modifiers we get very beautiful, real, lifelike panels while still maintaining very light topology.<br nodeIndex="234"><h3 nodeIndex="78">Step 07 &ndash; Create shapes with dynamic arrays</h3>

<div id="RIL_IMG_8" class="RIL_IMG"></div>
Arrays are absolutely crucial for defining complex shapes. Blender comes with a very powerful Array modifier &ndash; it enables us to create a sophisticated dynamic duplication of base meshes in the form of directional arrays, grids and radial arrays. Standard directional arrays are essential and need no introduction. More complex shapes, such as grids, can be created by simply combining two Array modifiers. You would use a fast-to-edit repetitive shape, which is similar to using patterns in a 2D app, which are instanced in the x and y direction. Since Array modifiers have the default option for Relative Offset, it ensures that each duplication is aligned side by side and can be welded to a previous one to create one seamless geometry piece. Blender offers you many ways to define radial arrays dynamically. The easiest way is to use Array modifier in combination with a Simple Deform modifier set to Blend mode (360 degrees). An even better way is to use the Object Offset option in the Array modifier, which works by applying transformation difference between two objects to each sequential array duplication. You can simply rotate one of the objects to see the effect.<br nodeIndex="238"><h3 nodeIndex="80">Step 08 &ndash; Kitbash methods</h3>

<div id="RIL_IMG_9" class="RIL_IMG"></div>
We often rely on IMM(s) and kitbashing libraries, however they have several limitations. Bigger pieces are great for certain projects (like mechs) but in general they limit our artistic freedom and dictate the final look. We are interested in an analogous workflow with Houdini, where each component is made of other individual components (nodes). This allows for a real, lifelike hierarchical approach where complex things are composed of many simple things. You can always import kitbash components (such as OBJ files), but we will also rely on asset referencing. To do that, define an independent BLEND file hosting your object library (kitbash components).<br nodeIndex="242"><h3 nodeIndex="82">Step 09 &ndash; Link objects</h3>

<div id="RIL_IMG_10" class="RIL_IMG"></div>
Now you can link or append particular objects to your main scene. This is like kitbashing with the advantage of preserving construction history, material and other data that you might care about. For example you could import a premade grid object (simple pattern) that comes with two Array modifiers, or some optics with all materials set up for you. You can link or append manually, however using a GUI is a far better solution! We used self-developed PyQt-based tools, but can recommend HardOps and Asset Manager add-ons. The latter lets you effortlessly store and retrieve any objects, including kitbash components. HardOps, on the other hand, is a very powerful feature-packed hard-surface modelling add-on with asset-loading functionality included.<br nodeIndex="246"><h3 nodeIndex="84">Step 10 &ndash; Work with isolated components</h3>

<div id="RIL_IMG_11" class="RIL_IMG"></div>
Blender comes with Scenes, and although intended for animation Scenes can be perfectly exploited to model our individual pieces. You can think of Scenes as having several other 3D &lsquo;files&rsquo; within the main 3D project file, with all the data being shared. We can use this to our advantage by allocating individual components to these scenes while retaining data linkage with the main scene &ndash; this is not the same as isolating a selection (local view). Instead it enables us to edit these components in the most comfortable, clutter-free environment without custom transformations. In essence it enables us to treat these components as independent artwork with our own details, layers and groups and so on.<br nodeIndex="250"><h3 nodeIndex="86">Step 11 &ndash; Booleans</h3>

<div id="RIL_IMG_12" class="RIL_IMG"></div>
An absolutely critical part of a hard-surface modelling workflow is Booleans. Problematically, traditional Boolean operations are collapsed into the main mesh, leaving no construction history. This makes maintaining them very manual and usually limits us to planar surfaces. In addition, Booleans do not get along with a subdivision workflow, cause triangulation and leave hard edges that require rounded corner shading. None of this is really a problem when you work with modifiers or nodes. In essence it enables us to set up a completely non-destructive and subdivision-friendly construction history. Our meshes remain light and easy to edit while Boolean operations are applied by the modifier non-destructively. If you want to have rounded edges after a Boolean operation, you can quickly add a Bevel modifier with an Angle Limit mode. As a result you eliminate the need for special rounded-edges rendering. We didn&rsquo;t use HardOps as we have custom tools (Python, Qt), but it&rsquo;s highly recommended as it makes work with Booleans effortlessly streamlined. BoolTools is also a good freeware alternative.<br nodeIndex="254"><h3 nodeIndex="88">Step 12 &ndash; Model with Houdini</h3>

<div id="RIL_IMG_13" class="RIL_IMG"></div>
Modelling is often overlooked in Houdini; it&rsquo;s an exceptionally powerful 3D program, however the processes of micromanaging everything and doing nodal modelling can be time-consuming. That is why finding the balance between a semi-procedural workflow in Blender and fully procedural workflow in Houdini was a key part of the process &ndash; more often than not, they were used hand in hand. A simple example would be adding detailing such as screws. In Blender, quads were placed onto geometry to mark where screws should be created. This mesh was shrinkwrapped (by a series of modifiers) to underlying objects, which makes it perfectly conform to surfaces even if the topology changes. It takes a moment to export these quads to Houdini, which automatically replaces them with perfectly aligned screws (Copy SOP, stamp). Another example is using Houdini&rsquo;s Cloth simulation to wrap a wire that is artistically defined in Blender. Simulating such things is an iterative process where geometry needs to be updated many times. As such, an automatic setup can save a lot of time. What an artist should take away from this step is that Houdini is not only a very powerful independent procedural modeller &ndash; it can also accelerate your work, offer complex plugin-like solutions and automate parts of your workflow when used together with another application.<br nodeIndex="258"><h3 nodeIndex="90">Step 13 &ndash; Refine UVs</h3>

<div id="RIL_IMG_14" class="RIL_IMG"></div>
What makes the workflow within Blender especially fun is that we can bypass linear step-by-step execution such as the requirement to complete the model before the retopology stage by doing final UVs, the 3D painting/texturing, and finally shading and rendering &ndash; these are all destructive steps that prevent further changes to model! Instead we want to be able to see where the project is going (the look dev) from the moment we create our first mesh. We also want to change the model and fix mistakes as we start rendering. How do we do that? We need to define some basic UVs. Blender offers us a very easy way to do so by creating a Project UV modifier (the UVW Map in 3ds Max). This is planar projection that can be elegantly set up on hundreds of objects. If the mesh is unsuitable for planar mapping, it takes a second to unwrap it manually as the layout is almost irrelevant. We simply want to keep stretching under control. We can also use screen-based mapping and procedural textures where applicable.<br nodeIndex="262"><h3 nodeIndex="92">Step 14 &ndash; Shade and render</h3>

<div id="RIL_IMG_15" class="RIL_IMG"></div>
With the UVs more or less automatically in place, we can now do basic texturing (scratches, carbon fibre and so on). How can we achieve more interesting effects, though, such as dust or edge wear? For dust we can read Geometry Normals, isolate up axis and multiply it by the Pointiness (vertex density). It will give us a perfect dust mask in cavities, which can then be multiplied by noise or a dust texture. Pointiness can also be useful for edge wear but it is unreliable unless you pay attention to mesh density near the edges while you are modelling. There are easier alternatives, though: Blender has very good vertex painting capabilities and it only takes a moment to paint the black-and-white mask on the edges where the effect is desired. The vertex paint data can be accessed using the Attribute node, which should be multiplied by procedural noise to get a decent edge wear mask. Remember, you can always retopologise as the very last step, and do the UVs and external texturing in another popular texturing program. Until then, you get very powerful look-dev options right inside Blender without the need to collapse nor fragment your workflow.<br nodeIndex="266"><h3 nodeIndex="94">Step 15 &ndash; Learn some Python</h3>

<div id="RIL_IMG_16" class="RIL_IMG"></div>
We have learned how to work largely non-destructively utilising modifiers, nodes and various workflow techniques. Our base meshes remain light, subdivision friendly and fast to edit. Modifiers do most of the hard work for us. With the full pipeline set up we can iteratively improve every part as long as needed. As mentioned previously, for the very last step you can always quickly retopologise, bake the geometry data and export for 3D painting to one of the leading applications. We would also like to advise familiarising yourself with Python as it can drastically accelerate your workflow in any application! Blender, in particular, is largely built on Python so knowing that will go a long way. Some of the tools used here are available at blenderartists.org as well as integrated into HardOps thanks to Jeremy Perkins. Lastly, perhaps it is fair if we get a chance to explain this somewhat confusing artwork thematic. It was created with the motive to highlight the hard work of developers that is behind every single Blender artwork!</div>